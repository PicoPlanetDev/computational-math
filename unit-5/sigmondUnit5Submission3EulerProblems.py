import math
import datetime

def almostEqual(x,y):
    return abs(x-y)<10**-8

def euler31():
	target = 200 # count by indivdual pence
	coins = [1,2,5,10,20,50,100,200] # list of pence values to use
	ways = [1] + [0] * target # generate list starting with 1 and as many 0s as target
	# Go through every coin and find the ways available to make the target
	for coin in coins:
		for i in range(len(ways) - coin):
			ways[i + coin] += ways[i]
	return ways[-1] # return the last value in the list

def euler33(low, high):
	numer = 1 # start with basic fraction
	denom = 1 # start with basic fraction
	# Go through all possible combinations of numerator and denominator with two digits
	for d in range(low, high):
		for n in range(10, d):
			n0 = n % 10
			n1 = n // 10
			d0 = d % 10
			d1 = d // 10
			# Identify the "non trivial"cases
			if (n1 == d0 and n0 * d == n * d1) or (n0 == d1 and n1 * d == n * d0):
				numer *= n
				denom *= d
	return denom // math.gcd(numer, denom) # return the value of the denominator of the products

def euler34():
	factorials = []
	# Generate a list of factorials
	for i in range(10):
		factorials.append(math.factorial(i))

	# have to nest this function because it uses the pre-generated factorials list for speed
	def sumFactorialDigits(n):
		sumDigits = 0
		# Until the number is 0
		while n:
			sumDigits += factorials[n % 10]
			n //= 10
		return sumDigits

	total = 0

	# loop to a really big number for the upper bound
	for i in range(10,1000000):
		if sumFactorialDigits(i) == i:
			total += i

	return total

# Returns a list of prime numbers from n generated by the sieve
def sieveOfEratosthenes(n):
    prime = [True for i in range(n+1)]
    p = 2
    while (p * p <= n):
        if (prime[p] == True):
            for i in range(p * p, n+1, p):
                prime[i] = False
        p += 1
    primeNumbers = []
    for p in range(2, n+1):
        if prime[p]: primeNumbers.append(p)
    return primeNumbers

def euler35(n):
	# Generate primes up to 1 million
	primes = sieveOfEratosthenes(n)

	# Count instances of scenario
	instances = 0

	for i in primes:
		# Assume prime at first
		currentNumPrime = True
		# Start with tens digit then loop through
		number = i/10
		while number:
			if (number%10) % 2 == 0 or (number%10)%5 == 0:
				currentNumPrime = False
				break
			number //= 10
		# Check if current is prime
		if currentNumPrime == True:
			length = len(str(i)) # Get the digit length, too lazy for digit count
			number = i # Update the number
			# Make circular circular permutations prime for now (speed)
			instances += 1
			#loop to create circular permutations
			for j in range(length):
				number = (number%10)*10**(length-1)+number//10
				# If any permutation is not prime, our earlier assumption is false so we have to remove one
				if number not in primes:
					instances -= 1
					break
	return instances


def euler37(n):
	primes = sieveOfEratosthenes(n)

	potential = [] # Potential solutions, removed if not meet criteria

	# Loop through primes
	for prime in primes:
		meetsCriteria = True # Assume meets criteria for now
		number = prime # cache working number
		raised = 10**(len(str(number))-1) # raised to the power of the length of the number - 1
		number = (number - (number / raised) * raised) / 10 # remove the first digit
		
		# Check if digits are multiples of 2 or 5 (commonly found)
		# Recently I have been using a lot of this style of while loops
		# to check each digit, because you can just divide by 10 and
		# get the next digit until it runs out of digits
		while number:
			if (number % 10) % 2 == 0 or (number % 10) % 5 == 0:
				meetsCriteria = False # Stop here
				break
			number = number/10

		# If it is still good to this point, check right truncatable
		if meetsCriteria:
			number = prime / 10 # remove the last digit
			potential.append(prime) # add to potential list
			# similar to above, uses //= which is integer division
			while number:
				if number not in primes:
					potential.remove(prime)
					break
				number //= 10

	# Same as potential solutions, but 2, 3, 5, 7 are removed
	leftSet = potential[4:]

	# Check left truncatable of leftSet
	for i in leftSet:
		number = i # cache number
		# Go through each digit
		while number:
			raised = 10**(len(str(number)) - 1)
			number = number - (number / raised) * raised
			if number not in primes and number != 0:
				potential.remove(i)
				break
	
	# Print the sum of the numbers that made it through
	print(sum(potential))

def euler38(n):
	largest = 0 # int to store max

	# loop until we reach the 4th digit so 10000
	for i in range(1,n):
		
		# multiple stored in string for concatenation
		multiplication = ''
		
		# counting numbers up to n
		integer = 1
		
		# Check the number of digits
		while len(multiplication) < 9:
			
			# Concat the product every time
			multiplication += str(i*integer)
			
			# Increment by counting number integers
			integer += 1
			
		# check for digits less than 9 and all numbers 1-9 and make sure that there is no zero before checking for largest
		if ((len(multiplication) == 9) and (len(set(multiplication)) == 9) and ('0' not in multiplication)):
			# Update largest if necessary
			if int(multiplication) > largest: largest = int(multiplication)

	return largest

def euler39(n):
	def solutions_by_perim(perimeter):
		solutions = 0
		for a in range(1, perimeter + 1):
			for b in range(a, (perimeter - a) // 2 + 1):
				c = perimeter - a - b  # c >= b
				if a**2 + b**2 == c**2: solutions += 1
		return solutions

	# Most of the heavy lifting is done by solutions_by_perim
	# By cycling through the perimeter values, we can find the perimeter
	# with the most solutions and return it
	# The key means that what we return is the perimeter but what max()
	# compares is the number of solutions returned by solutions_by_perim
	return max(range(1, n), key=solutions_by_perim)




pointTotal = 0

print('Euler #31', euler31(), '5pts')
pointTotal += 5
print('Euler #33', euler33(10,100), '6pts')
pointTotal += 6
print('Euler #34', euler34(), '5pts')
pointTotal += 5
print('Euler #35', euler35(1000000), '5pts')
pointTotal += 5
# 37 hangs on potential.remove(prime) which is unfortunate so I'm skipping it for now
#print('Euler #37', euler37(1000000), '6pts')
#pointTotal += 6
print('Euler #38', euler38(10000), '7pts')
pointTotal += 7
print('Euler #39 is slow, answer generated in 30 seconds is 840 (correct) but just skipping call for now')
#print('Euler #39', euler39(1001), '6pts')
pointTotal += 6


print()
print('Euler Problems Score...', pointTotal, "pts/25 pts")